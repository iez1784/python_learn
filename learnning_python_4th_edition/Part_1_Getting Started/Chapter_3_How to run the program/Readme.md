#### 第三章 如何运行程序 (P81 - P117)

- 当前常用的启动技术
- 如何交互地输入程序代码
- 如何将其保存至一个文件从而以后可以在系统命令中运行、图标点击、模块导入，以及IDLE这样的GUI中的菜单选项等内容
- 模块导入的内容，理解Python程序架构的基础
- 浏览一下IDLE和其他IDE的部分，从而了解什么样的工具更适合
_____________________________________________________________________
##### 交互提示模式下编写代码
- 解释器己经作为一个可执行程序安装在系统中了，开始交互解释对话的平台无关的方法，往旆就是在操作系统的提示环境下输入python，不需要任何参数
- C:\ python
  >>>
- Windows中，可以在DOS终端窗口中输入python
- UNIX、Linux以及Mac OS X中，在shell窗口或终端窗口中(xterm或终端中运行的ksh或csh这样的shell)输入pyhton
- 其他的系统可以采用类似的方法或平台特定的工具
- 如果你没有设置系统中shell的PATH环境变量，使其包含了Python的安装目录，你也许需要将"python"改为机器上Python可执行文件的完整路径。在UNIX或Linux上，可以输入 /usr/local/bin/python(或 /usr/bin/python)；在Windows上，可以尝试输入 C:\ Python30\python (3.0版本)
- 在Windows中，除了在shell窗口中输入phton，也可以通过启动IDLE的主窗口或者通过从Python的Start按钮菜单的选项中选择"Python (command line)"来开始类似的交互会话

#### 交互地运行代码
- Python交互对话刚开始时将会打印两行信息文本，然后显示等待输入新的Python语句或表达式的提示符>>>
- 在交互模式下工作，输入代码的结果将会在按下Enter键后在>>>这一行之后显示
- 退出交互对话并回到系统shell提示模式:
  1. 在UNIX系统中输入Ctrl-D退出
  2. 在MS-DOS和Windows系统中输入Ctrl-Z退出
  3. IDLE GUI中，也可以输入Ctrl-D退出或关闭窗口来退出
- 解释器在每行代码输入完成后，也就是按下回车后立即执行

#### 为什么使用交互提示模式
- 交互提示模式根据用户的输入运行代码并响应结果，但是，它不会把代码保存到一个文件中，不能在交互会话中编写大量的代码

##### 实验
- 由于代码是立即执行的，交互提示模式变成了实验这个语言的绝佳的地方
- 需要牢记的第一条原则: 当你对一段Python代码的运行有任何疑问的时候，马上打开交互命令并实验代码，看看会发生什么
- 通过交互提示模式接收到的直接反馈，通常是搞清楚一段代码到底做什么的最快的方式
- 这种体验方式不会带来任何破坏(至少目前还没有)
- 直接的Python代码总是可以安全运行的
- 当你犯一个错误的时候，不会导致Python或计算机崩溃，相反，你会得到一条有意义的出错消息，指出该错误以及出错的代码行，并且你可以继续自己的会话或脚本

##### 测试
- 交互式解释器也是测试己经写入到文件中的代码的好地方
- 可以交互地导入模块文件，并且通过在交互提示模式中输入命令从而在它们定义的工具上运行测试
- 在Python的标准库所附带的一个预编码的模块中测试一个函数(它显示出我们当前所工作的目录的名称)

```python
>>> import os
>>> os.getcwd()
'c:\\Python30'
```
- 交互提示模式是一个测试程序组件的地方，不需要考虑其源代码，你可以在Python文件中导入并测试函数和类，通过输入命令来连接C函数，在Jython中使用的Java类等
- Python支持了一种实验性和探索性的编程风格

#### 使用交互提示模式
- 常见错误的列表
  
  - 只能够输入Python命令
    1. 只能在Python交互模式下输入Python代码，而不要输入系统的命令
  
  - 在文件中打印语句是必须的
    1. 在交互解释器中自动打印表达式的结果，不需要在交互模式下输入完整的打印语句
    2. 在文件中需要写print，在交互模式下则不需要
  
  - 在交互提示模式下不需要缩进(目前还不需要)
    1. 当输入Python程序时，无论是在交互模式下还是在一个文体文件中，请确定所有没有嵌套胡语句都在第一列(也就是说要在最左边)，如果不是这样，Python也许会打印"SyntaxErro"的信息
    2. 第行开头的空格也会产生错误的消息
  
  - 留意提示符的变换和复合语句
    1. 当在交换模式下输入两行或多行的复合语句时，提示符会发现变化
    2. 在简单的shell窗口界面中，交互提示符会在第二行及后边的行由>>>变成...
    3. 在IDLE界面中，第一行之后的行会被自动缩进
    4. 由...改变回主提示模式>>>，点击回车键或Ctrl-C组合键
  
  - 在交互提示模式中，用一个空行结束复合语句
    1. 在交互提示模式中，要告诉交互式Pythonn己经输入完了多行语句，必须要插入一个空行(通过在这一行的起始处按下Enter键)，也就是说，必须按下Enter键两次，才能运行一条复合语句
    2. 相反，在文件中空行是不需要的，并且如果有的话也将会忽略
    3. 在交互模式下工作的时候，如果你没有在一条复合语句的末尾两次按下Enter键，将会陷入到尴尬胡境地，因为交互式解释器根本什么也不会做，它等你再次按下Enter键

  - 交互提示模式一次运行一条语句
    1. 在交互模式下，你必须运行完一条语句，然后才能输入另一条语句
    2. 对于简单语句来说，很自然。对于复合语句，记住必须提交一个空行来结束该语句，然后运行它，之后才能够输入下一条语句

#### 输入多行语句
- 在交互提示模式中，注意像结束for循环和if测试那样，用一个空行结束多行复合语句。必须两次按下Enter键，来结束整个多行语句，然后让其运行
  1. 在脚本文件中，复合语句的后面不需要空行；只在交互提示模式下，才需要该空行
  2. 在文件中，空行不是必须的，如果出现了的话，将会直接忽略掉；在交互提示模式中，它们会结束多行语句
- 交互提示模式每次只运行一条语句: 必须两次按下Enter键来运行一个循环或其他的多行语句，然后才能输入下一条语句
  1. 这意味着不能在交互提示模式中复制粘贴多行代码，除非这段代码的每条复合语句的后面都包含空行

### 系统命令行和文件
- 交互命令行对于实验来测试来说都很好，但是它也有一个很大的缺点: Python一旦执行了输入的程序之后，它们就消失了。在交互模式下输入的代码是不会保存在一个文件中的，所以为了能够重新运行，不复不从头开始输入
- 为了能够永久的保存程序，需要在文件中写入代码，这样的文件通常叫做模块
- 模块是一个包含了Python语句的简单文件文件
- 一旦编写完成，可以让Python解释器多次运行这样的文件中的语句，并且可以以多种方式去运行：
  1. 通过系统命令行
  2. 通过点图标
  3. 通过在IDLE用户界面中选择等方式
- 无论它是如何运行的，每次当你运行模块文件时, Python都会从头至尾执行模块文件中的每一条代码
- 模块文件常常作为Python写成的程序。也就是说，一个程序是由一系列预编写好的语句构成，保存在文件中，从而可以反复执行。可以直接运行的模块文件往往也叫做脚本(一个顶层程序文件的非正式说法)
- 有些人将"模块"这个说法应用于另一个文件所导入的文件

### 第一段脚本

##### script1.py  A first Python script
```python
# A first Python script
import sys              # Load a library module
print(sys.platform)
print(2 ** 100)         # Raise 2 to a power
x = 'Spam!'
print(x * 8)            # String repetition
``` 
-这个文件的作用
  - 导入一个Python模块(附加工具的库)， 以获取系统平台的名称
  - 运行3个print函数调用，以显示脚本的结果
  - 使用一个名为x的变量，在创建的蚨卢对其赋值，保存一个字符串对象

-程序说明:
  1. sys.platform只是一个字符串，它表示我们所工作的计算机的类型，它位于名为sys的标准Python模块中，我们必须导入以加载该模块
  2. #符号之后的文件是注释。 注释可以自成一行，也可以放置在代码行的右边 
  3. 这个模板文件叫做script1.py。对于所有的顶层文件，也应该直接叫做脚本，但是，要导入到客户端的代码的文件必须用.py后缀

### 使用命令行运行文件
- 一旦己经保存了这个文件本文，可以将其完整的文件名作为一条python命令的第一个参数，在系统shell提示中输入，从而要求Python来运行它:
```python
% python script1.py
win32
12676506000228229401496703205376
Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!
```
- 我们可以使用特定的shell语法，把一个Python脚本的输出定向到另一个文件中，从而保存起来以备以后使用或查看
```shell
% python script1.py > saveit.txt
```
- 在这个例子中，前面的运行中的3个输出行都存储到了saveit.txt，而不是显示出来。 这通常叫做流重定向(stream redirection)，它用于文件的输入和输出，而且在Windows和类似UNIX的系统上都可以使用

- 在Windows平台上工作，PATH环境变量设置也设置好了
  1. C:\Python30> python script1.py 执行脚本
- 如果PATH环境变量设置没有设好
  1. D:\temp> C:\python30\python script1.py
- 如果你所在的目录与工作的目录不同，别忘 了给出脚本文件的完整路径
  1. D:\other> C:\Python30\python c:\code\otherscript.py

### 使用命令行和文件
- 从系统命令行开始运行程序文件是相当直接明了的选择，特别是在通过你之前的日常工作己熟悉了命令行的使用时。
- 提示大家注意这些新手陷阱：
  - 注意Windows上的默认扩展名。
    1. 如果使用Windows系统的记事本编写程序文件，当保存文件时要注意选择所有文件类型，并指定文件后缀为.py，否则记事本会自动将文件保存成扩展名为.txt的文件
    2. Windows默认隐藏扩展名，所以除非改变查看选项
    3. 文件的图标
    4. 当在Windows下保存文件时，永远要选择所有文件，或者使用对程序员更加友好的文本编辑器
  - 在系统提示模式下使用文件扩展名，但是在导入时别使用文件扩展名
    1. 也就是说使用 python script1.py，而不是python script1
  - 在文件中使用print语句
    1. 交互式会话中是不需要print语句的，但是文件中是需要print语句
____________________________________________________________

### UNIX可执行脚本(#!)
- 如果在Python、Linux及其他的UNIX类系统上使用Python，可以将Python代码编程为可执行程序，就像使用Shell语言编写的csh或ksh程序一样。这样的脚本往往叫做可执行脚本
- UNIX风格的可执行脚本包含了Python语句的一般文本文件，但是有两个特殊的属性:
  1. 它们的第一行是特定的。脚本的第一行往往以字符#!开始(常常叫做"hash bang")，其后紧跟着机器Python解释器的路径
  2. 它们往往都拥有可执行的权限。 脚本文件往往通过告诉操作系统它们可以作为顶层程序执行，而拥有可执行的权限。在UNIX系统上，往往可以使用chmod +x file.py来实现这样的目的
- UNIX类系统例子。使用文本编辑器创建一个名为brian的文件:
```python
#!/usr/local/bin/python
print('The Bright Side' + 'of Life...')              # + means concatenate for strings
```

- 文件顶端的特定的一行告诉系统Python解释器保存在哪里
- 从技术上来看，第一行是Python注释
- 但是当第一行和这个文件一样的话，它就有特定的意义，因为操作系统使用它找到解释器来运行文件其他部分的程序代码
- 并且，注意这个文件命名为brian，而没有像之前模块文件一样使用.py后缀。但是因为这个文件中的代码并不打算被其他模块所导入，这个文件文件名是没有关系的(没有.py)，如果通过使用chmod +x brian这条shell命令赋予了这个文件可执行的权限，你就能够在操作系统的shell中运行它，就好像这是一个二进制文件一样:

```shell
% brain
The Bright Side of Life...
```
- Windows用户的一个提示: 这里介绍的方法是UNIX的一个技巧，也许它在你的平台上并不可行。但是别担心，可以使用我们刚才介绍的基本的命令行技术。在命令行中python后列出明确的文件名:
```shell
C:misc> python brain
The Bright Side of Life...
```
- 这种情况下，不老板娘语言件顶部的特定的#!注释(如果它还存在的话，Python会忽略它)，并且这个文件不需要赋予可执行的权限
- 事实上，如果可能想要在UNIX及微软Windows系统中都运行文件，如果经常采用基本的命令行的方法而不是UNIX风格的脚本去运行程序，你的生活或许会更简单一些
__________________________________________________
#### UNIX env查找技巧
- 在一些UNIX系统上，也许可以避免硬编码Python解释器的路径，而可以在文件特定的第一行注释中像这样写:
```python
#!/usr/bin/env python
...script goes here...
```
- 当这样编写代码的时候， env程序可以通过系统的搜索路径的位置定位Python荽释器。这种方法可以使代码更具有可移值性，因为没有必要在所有的代码中的第一行都硬编码Python的安装路径
- 假设在任何地方都能够使用env，无论Python安装在了系统的什么地方，你的脚本都可以照样运行: 跨平台工作时所需要做的仅仅是改变PATH环境变量，而不是脚本中的第一行。当然，这是env在任何系统中都是相同的路径的前提下(有些机器，还有可能在/sbin、/bin或其他地方)vk果不是的话，这种可移植性也就无从谈起了
_____________________________________________________
### 点击文件图标
- 在Windows下，注册表使通过点击图标打开文件变得很容易。当Python程序文件点击打开时Python自动注册为所运行的那个程序。正因如此，你可以通过使用鼠标简单的点击(或双击)程序的图标来运行程序
- 在非Windows系统中，也能够使用相似的技巧，但是图标、文件管理器、浏览的原理以及很多方面都有少许不同。
  1. 在一些UNIX系统上，也许需要在文件管理器的GUI中注册.py的扩展名，从而可以使用前一节介绍的#!技巧使脚本成为可执行的程序
  2. 使用应用程序关联文件的MIME类型
  3. 通过编辑文件、安装程序等命令
  4. 都使用其他的工具

#### 在Windows中点击图标
- 在系统中找到.py后缀名文件，双击图标(但是很多情况下就是一闪而过)

#### input的技巧
- 如果需要通过图标点击运行脚本，脚本输出后暂停，可以简单地在脚本的最后添加内置input函数的一条调用语句(Python 2.6中的raw_input)

```python
# A first Python script
import sys                  # Load a library module
print(sys.platform)
print(2 ** 100)             # Raise 2 to a power
x = 'Spam!'
print(x * 8)                # String repetition
input()                     # <== ADDED
```
- 一般来说，input读取标准输入的下一行，如果还没有得到的话一直等待输入
- 在这种情形下执行的实际效果就是让脚本暂停，直到按下回车键为止
- 在输入时所使用的input调用相当于在输出时使用的打印语句。这是读取用户输入的最简单的办法，并且实际上它比这个例子中的应用更全面例如，input
  1. 可选的接受字符串，这些字符串将作为提示打印出来  比如: input('Press Enter to exit')
  2. 以字符串的形式为脚本返回读入的文本  比如: nextinput = input()
  3. 在系统shell的层面上支持输入流的重定向 比如：python spam.py < input.txt， 就像输出时的打印语句一样

### 注意:
- 版本差异提示: 
  1. 如果你使用Python 2.6或者更早的版本，在这段代码中使用raw_input()而不要使用input()
  2. 在Python 3.0中，raw_input()重新命令为input()
  3. 从技术上讲，Python 2.6也有一个input，但是，它对字符串求值，就好像它们是输入到一个脚本的程序代码一样，因此，该函数在这个环境中无效(一个空字符串会产生错误)
  4. Python 3.0的input(以及Python 2.6中的raw_input())直接把输入的文本作为一个字符串返回，而不会求值。
  5. 要在Python 3.0中模拟Python 2.6的input， 使用eval(input())
___________________________________________________________________
#### 图标点击的其他限制
- 即使使用了input的技巧，点击文件图标仍有一定的风险
  1. 可能看不到Python的错误信息

#### 模块的导入和重载
- 用简单的术语来讲，每一个以扩展名py结尾的Python源代码文件都是一个模块
- 其他的文件可以通过导入一个模块读取这个模块的内容
- 导入从本质上来讲，就是载入另一个文件，并能够读取那个文件的内容
- 一个模块的内容通过这样的属性能够被外部世界使用
- 这种基于模块的方式使模块变成了Python程序架构的一个核心概念
- 更大的程序往往以多个模块文件的形式出现，并且导入了其他模块文件的工具。其中一个模块文件设计成主文件，或叫做顶层文件(就是那个启动后能够运行整个程序的文件)
- 被载入的文件通过导入操作最终可运行代码。正是如此，导入文件是另一种运行文件的方法

```python
C:\misc> c:\python30\python
>>> import script1
win32
12676506000228229401496703205376
Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!
```
- 这可以运行，但是在默认情况下，只是在每次会话的第一次运行
- 在第一次导入之后，其他的导入都不会再工作，甚至在另一个窗口中改变并保存了模块的源代码文件也不行
- 这是有意设计的结果。导入是一个开销很大的操作，以至于每个文件、每个程序运行不能够重复多于一次(第21章会了解，导入必须找到文件，将期编译成字节码，并且运行代码)
- 如果真的想要Python在同一次会话中再次运行文件(不停止和重新启动会话)，需要调用imp标准库模块中可用的reload函数(这个函数也是一个Python 2.6内置函数，但在Python 3.0中不是内置的)

```python
>>> from imp import reload      # Must load from module in 3.0
>>> reload(script1)
win32
65536
12676506000228229401496703205376
Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!
<module 'script1' from 'script1.py'
```
- 这里的from语句直接从一个模块中复制出一个名字
- reload函数载入并运行了文件最新版本的代码，如果己经在另一个窗口中修改并保存了它，那将反映出修改变化
- reload函数希望获得的参数是一个己经加载了的模块对象的名称，所以如果在重载之前，请确保己经成功地导入了这个模块。
- reload函数在模块对象胡名称前还需要括号，import则不需要
- reload是一个被调用的函数，而import是一个语句
- 这也就是为什么你必须把模块名称传递给reload函数作为括号中的参数，并且这也是在重载时得到了额外的一行输出的原因
- 最后一行输出是reload调用后的返回值的打印显示，reload函数的返回值是一个Python模块对象

#### 模块的显要特性: 属性
- 导入和重载提供了一种自然的程序启动的选择，因为导入操作将会在最后一步执行文件
- 从更宏观的角度来看，模块扮演了一个工具库的角色
- 从一般意义上来说， 模块往往就是变量名的封装，被认作是命名空间
- 在一个包中的变量名就是所谓的属性: 也就是说，属性就是绑定在特定的对象上的变量名(就像一个模块)
- 在典型的应用中，导入者得到了模块文件中在顶层所定义的所有变量名
- 这些变量名通常被赋值给通过模块函数、类、变量以及其他被导出的工具
- 这些往往都会在其他文件或程序中使用
- 从表面上看，一个模块文件的变理名可以通过两个Python语句读取 -- import和from，以及reload调用

- 创建一个名为myfile.py的单行Python模块文件，内容如下
```python
title = "The Meaning of Life"
```
- 当文件导入时，它的代码运行并生成了模块的属性。这个赋值语句创建了一个名为title的模块的属性
- 可以通过两种不同的办法从其他组件获得这个模块的title属性
  1. 通过使用一个import语句将模块作为一个整体载入，并使用模块名后跟一个属性名来获取

```python
% python                         # Start Python
>>> import myfile                # Run file: load module as a whole
>>> print(myfile.title)          # Use its attribute names: '.' to qualify
The Meaning of Life
```
- 一般来说，这里的点号表达式代表了object.attribute的语法，可以从任何的object中取出其任意的属性，并且这是Python代码中的一个常用操作。 在这里，我们己经使用了它去获取在模块myfile中的一个字符串变量title, 即myfile.title
  2. 作为替代方案，可以通过这样的语句从模块文件中获得 (实际上是复制) 变量名:

```python
% python                           # Start Python
>>> from myfile import title       # Run file: load module as a whole
>>> print(title)                   # Use its attribute names: '.' to qualify
The Meaning of Life
```
- from和import很相似，只不过增加了对载入组件的变量名的额外的赋值。从技术上讲，from复制了模块的属性，以便属性能够成为接收者的直接变量。因此，能够直接以title(一个变量)引用导入了字符串而不是myfile.title(一个属性引用)
- 无论使用的是impoort还是from去执行导入操作，模块文件myfile.py的语句都会执行，并且导入的组件(对应这里是交互提示模式)在顶层文件中得到了变量名的读取权。 这样一些对象就变成了可重用的组件，可以通过变量名被一个或多个客户端模块读取
- 在实际应用中，模块文件往往定义了一个以上的可被外部文件使用的变量名

#### treenames.py 定义了三个变量名
```python
a = 'dead'               # Define three attributes
b = 'parrot'             # Exported to other files
c = 'sketch'             
print(a, b, c)           # Also used in this file
```
- 文件treenames.py，给三个变量赋值，并对外部世界生成了三表属性，这个文件并且在一个print语句中使用它自有的三个变量，就像在其作为顶层文件运行时看到的结果一样:
```python
% python threenames.py
dead parrot sketch
```
- 所有的这个文件的代码运行起来就和第一次从其他地方导入(无论是通过import或者from)后一样。这个文件的客户端通过import得到了具有属性的模块，而客户端使用from时，则会获得文件变量名的复本

```python
% python
>>> import threenames                            # Grab the whole module
dead parrot sketch
>>>
>>> threenames.b,threenames.c
('parrot', 'sketch')
>>>
>>> from threenames import a, b, c               # Copy multiple names
>>> b, c
('parrot', 'sketch')
```
- 这里的结果打印在括号中，因为它们实际上是元组
- 一旦你开始就像这里一样在模块文件编写多个变量名，内置的dir函数开始发挥作用了
- 你可以使用它来获得模块内部的可用的变量名的列表

```python
>>> dir(threenames)
['__builtins__', '__doc__', '__file__', '__name__', '__package__', 'a', 'b', 'c']
```
- 当dir函数通过把导入模块的名称传至括号里，进行调用后，它将返回这个模块内部的所有属性
- 其中返回的一些变量名是 "免费" 获得的: 一些以双下划线开头并结结尾的变量名，这些通常都是由Python预定义的内置变量名，对于解释器来说有特定的意义

#### 模块和命名空间
- 模块导入是一运行代码文件的方法，模块同样是Python程序最大的程序结构
- Python程序往往由多个模块文件构成，通过import语句连接在一起
- 每个模块文件是一个独立完备的变量包，即一个命名空间
- 一个模块文件不能看到其他文件定义的变量名，除非它显示地导入了那个文件，所以模块文件在代码文件中起到了最小化命名冲突的作用
- 因为每个文件都是一个独立完备的命名空间，即使在它们拼写相同的情况下，一个文件中的变量名是不会与另一个文件中的变量冲突的
- 正是由于模块将变量封装为不同部分，Python具有了能够避免命名冲突的优点
- 目前而前，模块是一个不重复输入而可以反复运行代码的方法

#### import和reload的使用注意事项
- 让人变得困惑
  - 你需要记住是何时导入的，才能知道能不能够reload
  - 你需要记住当调用reload时需要使用括号，并且要记住让代码的最新版本运行时首先要使用reload
  - reload是不可传递的，重载一个模块的话只会重载该模块，而不能重载该模块所导入的任何模块，因此，有时候必须reload多个文件

- 由于上述麻烦的地方，从现在开始就要避免使用import和reload启动程序，这是一个好主意
- 如果用不常见的方法使用模块，可能遇到麻烦
- 现在，如果必须导入，为了避免复杂性，请将所有的文件放在同一目录下，同时将这个目录作为你的工作目录

- 也就是说，import和reload己经证明了是Python类中的一种常用测试技术，并且你可能也喜欢使用这种方法，然后，通常如果你发现自己碰壁了，那就停止继续碰壁

________________________________________
### 使用exec运行模块文件
- 还有更多的方法可以运行模块文件保存的代码。 比如: exec(open('module.py').read())内置函数调用，是从交互提示模式启动文件而不必导入以及随后的重载的一种方法。每次exec都运行文件的最新版本，而不需要随后的重载:

```python
C:\misc> c:\python30\python
>>> exec(open('script1.py').read())
win32
65536
12676506000228229401496703205376
Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!
```
...change script1.py in a text edit window...

```python
C:\misc> c:\python30\python
>>> exec(open('script1.py').read())
win32
4294967296 
12676506000228229401496703205376
Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam!
```
- exec调用有着类似于import的效果，但是，它从技术上不会导入模块，默认情况下，每次以这种方式调用exec的时候，它都重新运行文件
- exec不需要在文件修改后进行模块重载，它忽略了常规的模块导入逻辑
- 缺点是: 由于exec的工作机制好像在调用它的地方粘贴了代码一样，和前面提到的from一样，对于当前正在使用的变量有潜在的默认覆盖的可能。例如: 我们的script1.py赋给了一个名为x的变量。如果这个名字己经在exec调用的地方使用了，那么这个名称的值将被覆盖

```python
>>> x = 999
>>> exec(open('script1.py').read())           # Code run in this namespace by default
...same outout...
>>> x                                         # Its assignments can overwrite names here
'Spam!'
```

- 相反的，基本的import语句每个进程只运行文件一次，并且它会把文件生成到一个单独的模块名称空间中，以便它的赋值不会改变你的作用域中的变量。为模块名称空间分隔所付出的代价是，在修改之后需要重载


### IDLE用户界面
- IDLE软件提供了做Python开发的用户图形界面(GUI)， 而且它是Python系统的一个标准并免费的部分
- 被认为是一个集成开发环境(IDE)， 因为它在一个单独的界面中绑定了很多开发任务
- IDLE是一个能够编辑、运行、浏览和调试Python程序的GUI，所有都能够在单独的界面实现。
- 由于IDLE是使用Tkinter GUI工具包开发的Python程序，可以在几乎任何Python平台上运行， 包括: Windows、 X Windows(Linux、UNIX以及类Unix类平台) 以及 Mac OS (无论是Classic还是OS X)
- IDLE 是 IDE的一个官方变形，实际上是为了纪念Monty Python的成员Eric Idle而命名的

#### IDLE基础
- 在Windows中启动IDLE很容易: 在开始按钮的Python菜单中进行启动，并且也能够通过右键点击Python程序图标进行选择
- 在UNIX类系统中，需要在命令行中启动IDLE的顶层脚本，另一种办法是通过点击位于Pythonr Lib目录下的idlelib子目录下的idle.pyw或idle.py运行
- Windows中，IDLE位于"C:\Python30\Lib\idlelib"或者Python 2.6中"C:\Python26\Lib\idlelib"
- Python shell窗口是主窗口，一开始就被打开，并运行交互会话(注意到>>>提示符)
- IDLE可以使用友好的菜单并配合键盘快捷键进行绝大多数操作
- IDLE使用了语法导向的着色方法，对在主窗口输入的代码和文本编辑窗口的关键字使用的是一种颜色，常量使用的是另一种颜色
- 为了运行在IDLE中编辑的代码文件，首先选中文本编辑窗口，并点击窗口中的Run下拉菜单，选择列举在那里的Run Module选项(或者使用等效的键盘快捷键，快捷键在菜单中己给出)。如果己经在文件打开或最后一次保存后改变了文件，Python将会提醒需要首先保存文件(这是编程中常常深陷其中的错误)
- 当按照这种方式运行时，脚本的输出结果或错误信息可能在主交互窗口(Python shell 窗口)生成
- 窗口中部的"RESTART"后面的三行反映了在独立编辑窗口打开的script1.py脚本的执行情况
- "RESTART" 信息告诉我们用户脚本的进程重新启动以运行编辑的脚本，并为独立的脚本输出做好准备(如果IDLE己经在没使用用户代码子进程的情况下启动了，它将不会显示)

#### 注意
- 如果想要在IDLE主窗口中重复前一条命令，可以使用Alt-P组合键回滚，找到命令行的历史记录，并用Alt-N向前寻找 (Mac上，可以试试Ctrl-P和Ctrl-N)


#### 使用IDLE
- IDLE是免费、简单易用、可移植并自动支持绝大多数平台的
- IDLE新手应该在心中牢记的要点列表:
  - 当保存文件时，必须明确地添加 ".py"
  - 通过选择在文本编辑窗口Run->Run Module运行脚本，而不是通过交互模式的导入和重载
  - 你只需要重载交互地测试的模块
  - 可以对IDLE进行定制: Option菜单中的Configure选项
  - 在IDLE中没有清屏选项
  - Tkinter GUI和线程程序有可能不适用于IDLE
    1. 如果使用它运行特定类型的高级Python/Tkinter程序，有可能会没有响应
    2. 如果使用IDLE编辑GUI程序是永远安全的，最好使用其他的选项启动运行它们，有疑问时，如果代码在IDLE中发生错误，请在GUI外再试试
  - 如果发生了连接错误，试一下通过单个进程的模式启动IDLE: idle.py -n
  - 谨慎使用IDLE的一些可用的特性

#### 高级IDLE工具
- 高级的特性:指向点击(point-and-click)程序调试和对象浏览器
- IDLE的调试器是通过Dbug菜单进行激活的，而对象浏览器是通过File菜单激活的
- IDLE调试通过选择主窗口中的"Debug->Debuger菜单选项"来启动，之后通过选择文本编辑窗口的"Run->Run Module"选项开始运行脚本

#### 其他的IDE
- 常用的IDE:
  - Eclipse和PyDev
  - [Komodo](http://www.activestate.com)
  - NetBeans IDE Python版
  - PythonWin http://www.activestate.com
  - 其他(Wing IDE、 PythonCard)
  - Emacs和Vim
___________________________________________________
### 其他启动选项
- 还有运行Python代码的其他方法，其中大多数都有专门或有限的用途

#### 嵌入式调用
- 在一些特定的领域, Python代码也许会在一个封闭的系统中运行。在这样的情况下，我们说Python程序被嵌入在其他程序中运行
- Python代码可以保存到一个文本文件中、存储在数据库中、从一个HTML页面获取、从XML文件解析等
- 这样的嵌入执行模式一般用来支持终端用户定制的
- 在这种方式下，当使用Jython系统的时候，运行你的代码的封闭的系统可能是使用C、C++或者甚至Java编写的
  - 例如: 从C程序中通过调用Python运行API(Python在机器上编译时创建的由库输出的一系统服务)的函数创建并运行Python代码是可行的:
  ``` c
  #include <Python.h>
  ...
  Py_Initialize();                                         // This is C, not Python
  PyRun_SimplesTring("x = 'brave' + 'sir robin');          // But is runs Python code   
  ```
  - C代码片段中，用C语言编写的程序通过连接Python解释器的库嵌入了Python解释器，并传递给Python解释器一行Python赋值语句字符串去运行。C程序也可以通过使用其他的Python API工具获取Python的对象，并处理或执行它们

#### 冻结二进制的可执行性
- 冻结二进制的可执行性是集成了程序的字节码及Python解释器为一个单个的可执行程序的包。通过这种方式，Python程序可以像其他启动的任何可执行程序一样(图标点击，命令行等)被启动
- 尽管这个选择对于产品的发售相当适合，但它并不是一个在程序开发阶段适宜使用的选择
- 一般是在发售前进行封装(在开发完成之后)

#### 文本编辑器启动的选择
- [Python editors](http://www.python.org/editors)

#### 未来的可能

### 我应该选用哪种
- 新手: IDLE
- 有经验的程序员: 最喜欢使用的环境，就是最适合你用的环境

### 调试Python代码
- 现实世界的Python程序员调试代码时候常用的一些策略:
  - 什么也不做
    1. 阅读出错消息，并修改标记的行和文件
  - 插入print语句
    1. 在发布代码之前，删除掉或注释掉用来调试的print
  - 使用IDE GUI调试器
  - 使用pdb命令行调试器
    1. 为了实现最终控制，Python附带了一个名为pdb的源代码调试器，可以作为Python的标准库中的一个模块使用
  - 其他选项: 如果有更具体的调试需求，你可以在开源领域找到其他的工具，包括支持多线程程序、嵌入式代码和进程附件的工具
  - 错误本身是一种定义良好的机制，叫做异常


#### 本章小结
- 学习了启动Python程序的一般方法:
  - 通过交互地输入运行代码
  - 通过系统命令行运行保存在文件中的代码
  - 文件图标点击
  - 模块导入
  - exec调用以及像IDLE这样的IDE GUI

#### 本章习题
1. 怎样才能开始一个交互式解释器的会话
- Windwos下可以通过点击: 开始->程序->Python，选择Python(command line)
- 启动IDLE

2. 你应该在哪里输入系统命令行来启动一个脚本文件
- 在输入系统命令行的地方，也就是你所在的平台提供给作为系统终端的地方: 
  - 在Windows下的系统提示符
  - UNIX、Linux或Mac OS X上的xterm或终端窗口等

3. 指出运行保存在一个脚本文件中的代码的四种或更多的方法
- 一个脚本(实际上是模块) 文件中的代码可以通过系统命令行、文件鼠标点击、导入和重载、exec内置函数以及像IDLE的Run->Run Moudle菜单选项这样的IDE GUI选取来运行
- 在UNIX上，还可以使用#!技巧来运行，并且一些平台还支持更为专用的启动技术(例如，拖拽)
- 一些文件编辑器有运行Python代码的独特方式，一些Python程序作为独立的"冻结二进制"可执行文件提供
- 一些系统在嵌入式模式下使用Python代码，其中代码由C、C++或Java等语言编写的一个封闭程序自动运行。后几种技术通常用来提供一个用户定制层级

4. 指出在Windows下点击文件图标运行脚本的两个缺点
- 打印后退出的脚本会导致输出文件马上消失
- 你的脚本产生的同样显示在输出窗口的错误信息，会在查看其内容前关闭
- 默认情况下，Python每个进程只会导入(载入)一个模块一次，所以如果你改变了它的源代码，并且希望在不停止或者重新启动Python的情况下运行其最新的版本，你将必须重载它
- 在你重载一个模块之前至少己经导入了一次。在系统命令行中运行代码，或者通过图标点击，或者像使用IDLE这样的IDE

5. 在IDLE中怎样运行一个脚本
- 选择窗口的Run->Run Module菜单选项。这可以将这个窗口的源代码作为顶层脚本文件运行，并在交互Python shell窗口显示其输出

6. 列举2个使用IDLE的潜在的缺点
- IDLE在运行某种程序时会失去响应--特别是使用多线程的GUI程序
- IDLE在一些方便的特性在你一旦离开IDLE GUI时会伤害你

7. 什么是命名空间，它和模块文件有什么关系
- 命名空间就是变量(也就是变量名)的封装。
- 它在Python中以一个带有属性的对象的形式出现。每个模块文件自动成为一个命名空间:一个对变量的封装，这些变量对应了项层文件的赋值
- 命名空间可以避免在Python程序中的命名冲突--因为每个模块文件都是独立完备的命名空间，文件必须明确地导入其他的文件，才能使用这些文件的变量名

8. 文档
- [Python Docs](http://www.python.org/doc)








### 注2
- 在Windows中，还有一种完全阻止弹出DOS终端窗口的方法。以pyw为扩展名的文件只显示由脚本构建的窗口，而不是默认的DOS终端窗口。
- pyw 文件是拥这种特别的窗口的操作行为的.py文件
- 常常应用于Python编码的用户界面(这些用户界面的构建自己的窗口)， 和各种其他技术一起使用，把打印完成的输出和错误保存到文件中

### 注3 版本差异提示
- Python 3.0把reload内置函数移到了imp标分辨率库模埠中
  1. import imp --> imp.reload(M)
  2. from imp import reload --> reload(M)

### 注意
- import和from列出模块名时，都是使用myfile，没有.py后缀
- 当Python寻找实际文件时，知道在搜索程序中加上后缀名。然后，系统shell命令行中，一定要记得加上后缀名，但是import语句中则不用

### import VS from
- from语句在某种意义上战胜了模块的名称空间分隔的目的
- from把变量从一个文件复制到另一个文件，这可能导致在导入的文件中相同名称的变量被覆盖(并且,如果发生这种情况的话，不会为你给出警告)
- 这根本上会导致名称空间重叠到一起，至少在复制的变量上会重叠
- 作者建议用from， 不仅是因为from更短，而且因为它传说中的问题在实际中几乎不是问题

### 版本差异提示
- 除了允许exec(open('moudle.py'))的形式，Python 2.6也包含就表execfile('module.py')内置函数，这两个函数都会自动读取文件的内容
- 这两种形式都等同于exec(open('moudle.py').read())的形式，后都更为复杂，但是在Python2.6和Python3.0中都可以运行
- 这两种较简单的Python 2.6的形式，在Python 3.0中都不可用
- Python 3.0中的exec形式需要如皮多的录入，以至于最佳建议都是干脆不要使用它，通常启动文件的最好方式是输入系统shell命令或者使用IDLE菜单选项