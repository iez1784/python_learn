### 第5章 数字 (P150 - P187)

- 在Python中，数据采用了对象的形式--无论是Python所提供的内置对象，还是使用Python的工具像C这样的其他语言所创建的对象
- 事实上，编写的所有Python程序的基础就是对象
- 对象是Python编程中的最基本概念

### Python的数字类型
- 在Python中，数字并不是一个真正的对象类型，而是一组类似类型的分类
- Python不仅支持通常的数字类型(整数和浮点数), 而且能够通过常量去直接创建数字以及处理数字的表达式
- Python数字类型的完整工具包括:
  - 整数和浮点点
  - 复数
  - 固定精度的十进制数
  - 有理分数
  - 集合
  - 布尔类型
  - 无穷的整数精度
  - 各种数字内置函数和模块


#### 数字常量
- 在基本类型中，Python提供了:
  - 整数(正整数和负整数)
  - 浮点数(带有小数部分的数字)
- Python还允许我们使用十六进制、八进制和二进制常量来表示整数，提供一个复数类型，并且允许整数具有无穷的精度(只要内存空间允许，它可以增长成任意位数的数字)

##### 表 5-1 基本数字常量
数字 | 常量
:------ | :------
1234, -24, 0, 99999999999999 | 整数(无穷大小)
1.23, 1., 3.14e-10, 4E210, 4.0e+210 | 浮点数
0177,0x9ff,0b101010 | Python2.6中的八进制、十六进制和二进制常量
0o177,0x9ff，0b101010 | Python3.0中的八进制、十六进制和二进制常量
3+4j, 3.0+4.0j,3J | 复数常量

- Python的数字类型是很容易使用的，但是有些编程的概念需要在这里络调一下
  - 整数和浮点数常量
    - 整数以十进制数字的字符串写法出现
    - 浮点数带一个小数点，也可以加上一个科学计数标志e或者E
    - 如果编写一个带有小数点或幂的数字，Python会将它变成一个浮点数对象，并且当这个对象用在表达式中时，将启用浮点数(而不是整数)的运算法则
    - 浮点数就像C语言中的"双精度" 一样实现，因次，其精度与用来构建Python解释器的C编译器所给定的双精度一样
  
  - Python 2.6中的整数: 一般整数和长整数
    - Python2.6中有两种整数类型: 一般整数(32位)和长整数(无穷精度)， 并且一个整数可以l或L结尾，从而强迫其成为长整数
    - 由于当整数的值超过32位的时候会自动转换为长整数，我们不需要自己输入字母L，当需要客外的精度的时候，Python会自动地转换为长整数
  
  - Python 3.0中的整数: 一个单独的类型
    - 在Python 3.0中，一般整数和长整数类型己经合二为一了，只有整数这一种，它自动地支持Python 2.6中的单独的长整数类型所拥有的无穷精度。因此，整数在程序中不再用末尾的l或L表示，并且整数也不会再显示出这个字符
    - 除此之外，这一修改并没有影响到大多数程序，除非你确实进行类型测试来检测Python 2.6的长整数
  
  - 十六进制数、八进制和二进制常量
    - 整数可以编写为十进制(以10为基数)、十六进制(以16为基数)、八进制(以8为基数)和二进制(以2为基数)形式
    - 十六进制数以0x或0X开头，后面接十六进制的数字0~9和A~F
    - 八进制数常量以数字0o或0O开头(0和小写或大写字母"o")，后面接着数字0~7构成的字符串
    - 在Python 2.6及更早的版本中，八进制常量也可以写成前面只有一个0的开式，但在Python 3.0中不能这样(这种最初的八进制形式太容易与十进制数混淆，因此用新的0o的形式替代了)
    - Python 2.6和Python 3.0中的新的二进制常量，以0b或0B开头，后面跟着二进制数字(0~1)
    - 注意所有这些常量在程序代码中都产生一个整数对象，它们仅仅是特定值的不同语法表示而己
    - 内置函数hex(I)、oct(I)和bin(I)把一个整数转换为这3种进制表示的字符串，并且int(str, base)根据每个给定的进制把一个运行时字符串转换为一个整数

  - 复数
    - Python的复数常量写成实部+虚部的写法，这里虚部是以j或J结尾
    - 其中，实部从技术上讲可有可无，所以可能会单独表示虚部
    - 从内部看来，复数都是通过一对浮点数来表示的，但是对复数的所有的数字操作都会按照复数的运算法则进行
    - 也可以通过内置函数complex(real, imag)来创建复数

  - 编写其他的数字类型
    - 其中的一些通过调用导入的模块中的函数来创建(例如: 十进制和分数)

#### 内置数学工具的扩展
- Python还提供了一系列处理数字对象的工具:
  - 表达式操作符: +、-、*、/、>>、**、&等
  - 内置数学函数: pow、abs、round、int、hex、bin等
  - 公用模块: random、math等

- 尽管数字主要是通过表达式、内置函数和模块来处理，它们如今天也拥有很多特定于类型的方法
- 整数有各种各样的属性
- 集合既像一些集合一样也像一些数字一样，它也支持这两者的方法和表达式
- 表达式是大多数数字类型最基本的工具

### Python表达式操作符
- 表达式是处理数字的最基本的工具
- 当一个数字(或其他对象)与操作符相结合时，Python执行时将计算得到一个值
- 在Python中，表达式是使用通常的数学符号和操作符号写出来的

# 表5-2: Python表达式操作符及程序
操作符 | 描述
:------ | :------
yield x | 生成器函数发送协议
lambda args: expression | 生成匿名函数
x if y else: expression | 三元选择表达式
x or y | 逻辑或(只有x为假，才会计算y)
x and y | 逻辑与(只有x为真，才会计算y)
not x | 逻辑非
x in y, x not in y | 成员关系(可迭代对象、集合)
x is y, x is not y | 对象实体测试
x < y, x <= y, x > y, x >= y, x == y, x!= y | 大小比较，集合子集和超集值相等性操作符
x `<|>` y | 位或，集合并集
x ^ y | 位异或，集合交集
x & y | 位与，集合交集
x << y, x >> y | 左移或右移y位
x + y, x - y | 加法/合并，差法，集合差集
x * y, x % y, x / y, x // y | 乘法/重复，余数/格式化，除法: 真除法或floor除法
-x, +x | 一元减法，识别
~x |  按位求补(取反)
x ** y | 幂运算
x[i] | 索引(序列、映射及其他)点号取属性运算，函数调用
x[i:j:k] | 分片
x(...) | 调用(函数、方法、类及其他可调用的)
x.attr | 属性引用
(...) | 元组，表达式，生成器表达式
[...] | 列表，列表解析
{...} | 字典、集合、集合和字典解析

- 关于表5-2中的操作符的版本差异和最新添加:
  - Python 2.6中，值不相等可以写成 X != Y 或 X <> Y，在Python 3.0这中，值不相等测试使用 X != Y， 去掉了<>
  - 在Python 2.6中，一个后引号表达式'X'和repr(X)的作用相同，转换对象以显示字符串，由于其不好理解，Python 3.0 删除了这个表达式，使用更易理解的str和repr内置函数
  - 在Python 2.6和Python 3.0中，floor除法表达式(X // Y) 总是会把余数小数部分去掉;在Python 3.0中，X / Y 表达式执行真正的除法(保留余数) 和Python 2.6中的传统除法(截除为整数)
  - 列表语法([...])用于表示列表常量或列表解析表达式。后者是执行隐性循环，把表达式的结果收集到新的列表中
  - (...)语法用于表示元组和表达式，以及生成器表达式，后者是产生所需结果的列表解析的一种形式，而不是构建一个最终的列表
  - {...}语法表示字典常量，并且在Python 3.0中可以表示集合常量以及字典和集合解析
  - yield和三元选择表达式在Python 2.5及期以后的版本中可用。前者返回生成器中的send(...)参数，后者是一个多行if语句的缩写形式。如果yield不是单独地位于一条赋值语句的右边的话，需要用圆括号
  - 比较操作符可以连续使用: X < Y < Z的结果与 X < Y and Y < X相同
  - 在最近的Python中，分片表达式X[I:J:K]等同于用一个分片对象索引: X[slice(I, J, K)]
  - 在Python 2.X，混合类型的广义比较是允许的(把数字转换为一个普通类型，并且根据类型名称来排列其他的混合类型)。 在Python3.0中，非数字的混合类型的大小比较是不允许的，并且发异常，这包括按照代理排序
  - 在Python 3.0中，对字典的大小比较也不再支持(尽管支持相等性测试)；比较sorted(dict.items())是一种可能的替代

#### 混合操作所遵循的操作符优先级
- 当编写含有一个操作符以上的表达式时，Python将按照所谓的优先级法则对其进行分组，这个分组决定了表达式中部分的计算顺序

##### 表5-2根据操作符的优先级来排序
- 在表5-2中，表的操作符中越靠后的优先组越高，因此在混合表达式中要更加小心
- 表5-2中位于同一行的表达式在组合的时候通常从左到右组合(除了幂运算，它是从右向左组合的，还有比较运算，是从左到右连接的)

#### 括号分组的子表达式
- 如果用括号将表达式各部分进行分组的话，就可以完全忘掉优先级的事情了
- 当使用括号划分子表达式的时候，就会超越Python的优先级规则
- Python总会先行计算括号中的表达式，然后再将结果用在整个表达式中
- 在一个大型表达式中增加括号是个很好的方法，它不仅仅强制按照你想要的顺序进行计算，同时也增加了程序可读性

#### 混合类型自动升级
- 除了在表达式中混合操作符以外，也能够混合数字的类型
- 在混合类型的表达式中，Python首先将被操作的对像转换成其中最复杂的操作对象的类型，然后再对相同类型的操作对象进行数学运算
- Python是这样划分数字类型的复杂度的:
  - 整数比浮点数简单，浮点数比复数简单
  - 任何混合类型的表达式，其中一个操作对象是更为复杂的数字，则会导致其他的操作对象升级为一个复杂的数字，使得表达式获得一个复杂的结果
- 可以通过手动调用内置函数来强制转换类型;(然而，通常是没有必要这样做的。Python在表达式中自动升级为更复杂的类型，其结果往往就是你所想要的)
- 要记住所有这些混合类型转换仅仅在将数字类型(比如：一个整数和一个浮点数)混合到一个表达式中的时候才适用，这包括那些使用数字和比较操作符的表达式
- 一般来说，Python不会在其他的类型之间进行转换，除非你手动转换其中某个的类型
- 注意: 
  - Python 2.6中，非数字混合类型也可以比较，但是，不执行转换(混合类型的比较根据一个确定但任意的规则)
  - 在Python 3.0中，非数字混合类型的比较是不允许的，并且会引发异常

##### 预习: 运算符重载
- 留心所有的Python操作符可以通过Python的类或C扩展类型被重载(即实现)，让它也能工作于你所创建的对象中
- Python自身自动重载了某些操作符，能够根据所处理的内置对象的类型而执行不同的操作
- 这种特性通常称作多态。这个术语指操作的意义取决于所操作的对象的类型

### 在实际应用中的数字
- 最好的理解数字对象和表达式的方法就是看看它们在实际中的应用

#### 变量和基本的表达式
- 变量在它第一次赋值时创建
- 变量在表达式中使用将被替换为它们的值
- 变量在表达式中使用以前必须己赋值
- 变量像对象一样不需要在一开始进行声明

##### 换句话说，这些赋值会让变量a和b自动生成:
```python
% python
>>> a = 3                 # name created
>>> b = 4
```
- 文档字符串，即对象上附加的注释的文本
```python
>>> a + 1, a -1                   # Addition(3 + 1)，subtraction(3 -1)
(4, 2)
>>> b * 3, b / 2                  # Multiplication(4 * 3)， dvision(4/2)
(12, 2.0)
>>> a % 2, b ** 2                 # Modulus(remainder), power(4 ** 2)
(1, 16)
>>> 2 + 4.0, 2.0 ** b             # Mixed-type conversions
(6.0, 16.0)
```
- 从技术上讲，这里的会显示所得到的结果是有两个值的元组，因为输入在提示符的那行包含了两个被逗号分开的表达式
- 这也就是显示的结果包含在括号里的原因
- 如果使用一个从未被赋值的不同的变量，Python将会报告有错误而不是赋给默认的值

```python
>>> c * 2
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
NameError: name 'c' is not defined
```

- 在Python中，变量并不需要预声明，但是在使用之前，至少要赋一次值
- 这意味着在对其进行加法运算时要计数器初始化为0， 在列表后添加元素前，要首先初始化列表为一个空列表

```python
>>> b / 2 + a                   # Same as ((4 / 2) + 3 )
5.0
>>> print(b / (2.0 + a))        # Same as (4 / (2.0 + 3))
0.8 
```
- 在第一个表达式中，没有括号，所以Python自动根据运算符的优先级法则将各部分分组
- "/" 比 "+" 位置靠后，它的优先级更高，所以首先进行"/"运算
- 在第二个表达式中，括号用在"+"的周围，强制使Python首先计算"+"(优先于"/")

#### 数字显示的格式
- 如果不用print，可能看到的结果感到奇怪

```python
>>> b / (2.0 + a )                    # Auto echo output: more digits
0.80000000000000004

>>> print(b / (2.0 + a))              # print rounds off digits
0.8
```
- 在这个奇怪的结果背后的真正原因是浮点数的硬件限制，以及它无法精确地表现一些值
- 只是一个显示问题--交互提示模式下结果的自动回显会比打印语句显示更多的数字位数
- 如果你不像看到所有的位数，使用print

- 并且除了打印和自动回湿之外，还有很多种方法显示计算机中的数字的位数

```python
>>> num = 1 / 3.0
>>> num                               # Echoes
0.33333333333333331
>>> print(num)                        # print rounds
0.3333333333333

>>> '%e' % num                        # String formatting expression
'3.333333e-001'

>>> '%4.2f' % num                     # Alternative floating-point format
'0.33'

>>> '{0:4.2f}'.format(num)            # String formatting method
```

- 这些方法中的最后三个使用了字符串格式化

#### 比较: 一般的和连续的
- 它们比较操作数的相对大小，并且返回一个布尔类型的结果

```python
>>> 1 < 2              # Less than
True
>>> 2.0 >= 1           # Greater than or equal: mixed-type 1 converted to 1.0
True
>>> 2.0 == 2.0         # Equal value
True
>>> 2.0 != 2.0         # Not equal value
False
```

###### str和repr显式格式
- 从技术上来说，默认的交互模式回显和打印的区别就相当于内置repr和str函数的区别

```python
>>> num = 1 / 3
>>> repr(num)                  # Used by echoes: as-code form
```
- 这两个函数都会把任意对象换成它们的字符串表示: repr(也就是默认的交互模式回显)产生的结果看起来就好像它们是代码
- str(也就是打印语句)转变为一种通常对用户更加友好的格式
- 一些对象两种方式都有: str用于一般用途，repr用于额外细节
- 除了为任意对象提供打印字符串，str内置函数也是字符串数据类型的名字，并且能够用一个编码的名字来调用，从而从一个字节字符串解码一个Unicode字符串

```python
>>> 2.0 == 2.0         # Equal value
True

>>> 2.0 != 2.0         # Not equal value
False
```
- 注意数字表达式中是如何允许混合类型的(仅仅是数字表达式)
- 第二个测试中，Python比较了更为复杂的类型(浮点类型)的值

- Python允许把多个比较连续起来执行范围测试
- 连续的比较是更大的布尔表达式的缩写
- 简单而言之，Python允许我们把大小比较测试连接起来，成为诸如范围测试的连续比较
  - 例如，表达式(A < B < C)测试B是否在A和C之间；它等同于布尔测试(A < B and B < C)，但更容易辨识

```python
>>> X = 2
>>> Y = 4
>>> Z = 6
```      
- 如下的两个表达式具有相同的效果，但是，第一个表达式简单而便玩录入，并且，由于Python只需要计算Y一次，它运行起来可能略快一点
```python
>>> X < Y < Z              # Chained comparisons: range tests
True

>>> X < Y and Y < Z
True
```                                                                                                                              
- 获得false结果也是一样的，并且允许任意的连续长度:
```poython
>>> X < Y > Z
False

>>> X < Y and Y > Z
False

>>> 1 < 2 < 3.0 < 4
True

>>> 1 > 2 > 3.0 > 4
False
```  
- 可以在连续测试中使用其他的比较，但是，最终的表达式可能变得很晦涩，除非你按照Python的方式来计算它们

```python
>>> 1 == 2 < 3             # Same as: 1 == 2 and 2 < 3
False                      # Not same as: False < 3 (which means0 < 3, which is true)
```

- Python并不会把 1 == 2r False的结果和3进行比较，这样做的话，在技术上的含义和 0 < 3相同，将会得到True

#### 除法: 传统除法、Floor除法和真除法
在Python3.0和Python2.6中略有差异，实际上，有3种类型的除法，有两种不同的除法操作符，其中一种操作符在Python3.0中有了变化

- X / Y
  - 传统除法和真除法
  - 在Python2.6或之前的版本中，这个操作对于整数会省去小数部分，对于浮点数会保持小数部分
  - 在Python3.0版本中将会变成真除法(无论任何类型都会保持小数部分)

- X // Y
  - Floor除法
  - 在Python2.2中新增的操作，在Python2.6和Python3.0中均能使用
  - 这个操作不考虑操作对象的类型，总会省略掉结果的小数部分，剩下最小的能整除的整数部分

添加真除法是为了解决最初的传统除法的结果依赖于操作数类型这一现象。由于这一限制，Python3.0取消了传统除法: /和//操作符在Python3.0中分别实现真除法和Fllor除法

概括的讲:
- 在Python3.0中， /现在总是执行真除法，不管操作数的类型，都返回包含任何余数的一个浮点结果。//执行Floor除法，它截除掉余数并且针对整数操作数返回一个整数，如果有任何一个操作数是浮点类型，则返回一个浮点数
- 在Python2.6中，/表示传统除法，如果两个操作数都是整数的话，执行截断的整数除法；否则，执行浮点除法(保留余数)。//执行Floor除法，并且像在Python3.0中一样工作，对于整数执行截断除法，对于浮点数执行浮点除法
```python
C:\misc> C:\Python30\python
>>>

>>> 10 / 4                          # Differs in 3.0: keeps remainder
2.5

>>> 10 // 4                         # Same in 3.0: truncates remainder
2

>>> 10 // 4.0                       # Same in 3.0: truncates to floor
2.0

C:\misc> C:\Python26\python
>>>

>>> 10 / 4                          
2

>>> 10 // 4                         
2

>>> 10 / 4.0                       
2.5

>>> 10 // 4.0
2.0

```
注意: 在Python3.0中
- //的结果的数据类型总是依赖于操作数的类型: 如果操作数中有一个是浮点数，结果就是浮点数;否则，结果是一个整数
- 尽管这可能与Python 2.X中类型依赖行为类似(正是该因素引发了在Python 3.0中的变化)， 但返回值类型的差异比返回值本身的差异要轻微很多
- 对于依赖截断整数除法的程序(这种程序可能比你所意识到的要更为常见)， //作为向后兼容工具的一部分而提供，对于整数类型，它必须返回整数

##### 支持两个Python版本
- 尽管/的行为在Python2和Python3.0中不同，我们仍然能够在自己的代码中支持这两个版本
- 如果你的程序依赖于截断整数除法，在Python2.6和Python3.0中都使用//
- 如果你的程序对于整数需要带有余数的浮点数结果，使用浮点数，从而确保代码在Python2.6中运行的时候/的一个操作数是浮点数:

```python
X = Y // Z              # Always truncates, always an int result for ints in 2.6 and 3.0

X = Y / float(Z)        # Guarantees float division with remainder in either 2.6 or 3.0
```

- 作为替代方法，可以使用一个 __future__import在Python2.6中打开Python3.0的/，而不是用浮点转换来强制它:
```python
C:\misc> C:\Python30\python
>>> from __future__ import division           # Enable 3.0 "/" behavior
>>> 10 / 4
2.5

>>> 10 // 4
2
```

#### Floor除法VS截断除法
- //操作符通常叫做截断除法，但是，更准确的说法是floor除法，它把结果向下截断到它的下层，即真正结果之下的最近的整数。其直接妆效果是向下舍入，并不是严格地截断，并且这对负数也有效
- 你可以使用Python的math模块来自己查看其中的区别(在使用模块中的内容之前，必须先导入模块;随后将更详细地介绍这些内容)
```python
>>> import math
>>> math.floor(2.5)
2

>>> math.floor(-2.5)
-3

>>> math.trunc(2.5)
2

>>> math.trunc(-2.5)
-2
```
- 在执行除法操作的时候，只是真正地截断了正的结果，因此截断除法和floor除法是相同的
- 对一负数，它就是一个floor结果(实际上，它们都是floor，但是对于正数来说，floor和截断是相同的)

```python
C:\misc> C:\Python30\python
>>> 5 / 2, 5 / -2
(2.5, -2.5)

>>> 5 // 2, 5 // -2                 # Truncates to floor: rounds to first lower integer
(2, -3)                             # 2.5 becomes 2, -2.5 becomes -3

>>> 5 / 2.0, 5 / -2.0
(2.5, -2.5)

>>> 5 // 2.0, 5 // -2.0             # Ditto for floats, though result is float too
(2.0, -3.0)
```

```python
C:\misc> C:\Python26\python
>>> 5 / 2, 5 / -2                   # Differs in 3.0
(2, -3)

>>> 5 // 2, 5 // -2                 # This and the rest are the same in 2.6 and 3.0
(2, -3)                             

>>> 5 / 2.0, 5 / -2.0
(2.5, -2.5)

>>> 5 // 2.0, 5 // -2.0 
(2.0, -3.0)     
```

- 如果你真的想要截断而不管符号，可以总是通过math.trunc来得到一个浮点除法结果，而不管是什么Python版本(请查看内置的round函数以了解相关的功能)
```python
>>> C:\misc> C:\Python30\python
>>> import math
>>> 5 / -2                          # Keep remainder
-2.5

>>> 5 // -2                         # Floor below result
-3

>>> math.trunc(5 / -2)              # Truncate instead of floor
-2

C:\misc> C:\Python26\python
>>> import math
>>> 5 / float(-2)                   # Remainder in 2.6
-2.5

>>> 5 / -2 , 5 // -2                # Floor in 2.6
(-3, -3)

>>> math.trunc(5 / float(-2)              # Truncate in 2.6
-2
```

##### 为什么截断很重要
- 如果使用Python 3.0
```python
>>> (5 / 2), (5 / 2.0), (5 / -2.0), (5 / -2)                   # 3.0 true division
(2.5, 2.5, -2.5, -2.5)

>>> (5 // 2), (5 // 2.0), (5 // -2.0), (5 // -2)               # 3.0 floor division
(2, 2.0, -2.5, -2.5)

>>> (9 // 3), (9.0 / 3), (9 // 3), (9 // 3.0)                  # Both
(3.0, 3.0, 3.0, 3.0)
```

- Python 2.6的用户
```python
>>> (5 / 2), (5 / 2.0), (5 / -2.0), (5 / -2)                   # 2.6 classic division
(2.5, 2.5, -2.5, -3)

>>> (5 // 2), (5 // 2.0), (5 // -2.0), (5 // -2)               # 2.6 floor division (same)
(2, 2.0, -3.0, -3)

>>> (9 // 3), (9.0 / 3), (9 // 3), (9 // 3.0)                  # Both
(3, 3.0, 3, 3.0)
```
- 尽管还是得出来了结果，但是，Python3.0中/的非截断行为还是可能会影响到大量的程序
- 可能是因为C语言的遗留原因，很多程序员依赖于整数的截断除法，因皮他们必须学习在这样的环境中使用//

##### 整数精度
- Python 3.0整 数支持无穷的大小:
```python
>>> 999999999999999999999999999999 + 1
1000000000000000000000000000000
```
- Python2.6针对长整数有一个单独的类型，但是，它自动地把任何太大了以至于无法存储到一般整数中的数字转换为这种类型
- 因此，要使用长整数，我们不需要纺写任何特殊的语法，并且，可以识别出在使用了Python2.6长整数的唯一方法就是它们的末尾显示一个"L"
```python
>>> 999999999999999999999999999999 + 1
1000000000000000000000000000000L
```
- 无穷大整数是一个方便的内置工具
- Python为了支持扩展的精度，需要额外的工作，在实际应用中，长整型数的数学运算通常要比正常的整数运算(它是直接与硬件相关的)更慢
- 如果需要精度，性能就要损失

##### 复数
- 在Python中，复数是个不同的核心对象类型
- 复数表示为两个浮点数(实部和虚部)并接在虚部增加了j或J的后缀
- 我们能够把非零的复数写成由+连接起来的两部分
  - 一个复数的实部为2并且虚部为-3可以写成: 2 + -3j
```python
>>> 1j * 1J
(-1+0j)

>>> 2 + 1j * 3
(2+3j)

>>> (2+1j) *3
(6+3j)
```
- 复数允许我们分解出它的实部和虚部作为属性，并支持所有一般的数学表达式，并且可以通过标准的cmath模块(复数版的标准数学模块)中的工具进行处理
- 复数通常在面向工程的程序中扮演重要的角色
- 它是高级的工具

P167