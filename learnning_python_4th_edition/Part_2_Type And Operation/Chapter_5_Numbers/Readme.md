### 第5章 数字 (P150 - P187)

- 在Python中，数据采用了对象的形式--无论是Python所提供的内置对象，还是使用Python的工具像C这样的其他语言所创建的对象
- 事实上，编写的所有Python程序的基础就是对象
- 对象是Python编程中的最基本概念

### Python的数字类型
- 在Python中，数字并不是一个真正的对象类型，而是一组类似类型的分类
- Python不仅支持通常的数字类型(整数和浮点数), 而且能够通过常量去直接创建数字以及处理数字的表达式
- Python数字类型的完整工具包括:
  - 整数和浮点点
  - 复数
  - 固定精度的十进制数
  - 有理分数
  - 集合
  - 布尔类型
  - 无穷的整数精度
  - 各种数字内置函数和模块


#### 数字常量
- 在基本类型中，Python提供了:
  - 整数(正整数和负整数)
  - 浮点数(带有小数部分的数字)
- Python还允许我们使用十六进制、八进制和二进制常量来表示整数，提供一个复数类型，并且允许整数具有无穷的精度(只要内存空间允许，它可以增长成任意位数的数字)

##### 表 5-1 基本数字常量
数字 | 常量
:------ | :------
1234, -24, 0, 99999999999999 | 整数(无穷大小)
1.23, 1., 3.14e-10, 4E210, 4.0e+210 | 浮点数
0177,0x9ff,0b101010 | Python2.6中的八进制、十六进制和二进制常量
0o177,0x9ff，0b101010 | Python3.0中的八进制、十六进制和二进制常量
3+4j, 3.0+4.0j,3J | 复数常量

- Python的数字类型是很容易使用的，但是有些编程的概念需要在这里络调一下
  - 整数和浮点数常量
    - 整数以十进制数字的字符串写法出现
    - 浮点数带一个小数点，也可以加上一个科学计数标志e或者E
    - 如果编写一个带有小数点或幂的数字，Python会将它变成一个浮点数对象，并且当这个对象用在表达式中时，将启用浮点数(而不是整数)的运算法则
    - 浮点数就像C语言中的"双精度" 一样实现，因次，其精度与用来构建Python解释器的C编译器所给定的双精度一样
  
  - Python 2.6中的整数: 一般整数和长整数
    - Python2.6中有两种整数类型: 一般整数(32位)和长整数(无穷精度)， 并且一个整数可以l或L结尾，从而强迫其成为长整数
    - 由于当整数的值超过32位的时候会自动转换为长整数，我们不需要自己输入字母L，当需要客外的精度的时候，Python会自动地转换为长整数
  
  - Python 3.0中的整数: 一个单独的类型
    - 在Python 3.0中，一般整数和长整数类型己经合二为一了，只有整数这一种，它自动地支持Python 2.6中的单独的长整数类型所拥有的无穷精度。因此，整数在程序中不再用末尾的l或L表示，并且整数也不会再显示出这个字符
    - 除此之外，这一修改并没有影响到大多数程序，除非你确实进行类型测试来检测Python 2.6的长整数
  
  - 十六进制数、八进制和二进制常量
    - 整数可以编写为十进制(以10为基数)、十六进制(以16为基数)、八进制(以8为基数)和二进制(以2为基数)形式
    - 十六进制数以0x或0X开头，后面接十六进制的数字0~9和A~F
    - 八进制数常量以数字0o或0O开头(0和小写或大写字母"o")，后面接着数字0~7构成的字符串
    - 在Python 2.6及更早的版本中，八进制常量也可以写成前面只有一个0的开式，但在Python 3.0中不能这样(这种最初的八进制形式太容易与十进制数混淆，因此用新的0o的形式替代了)
    - Python 2.6和Python 3.0中的新的二进制常量，以0b或0B开头，后面跟着二进制数字(0~1)
    - 注意所有这些常量在程序代码中都产生一个整数对象，它们仅仅是特定值的不同语法表示而己
    - 内置函数hex(I)、oct(I)和bin(I)把一个整数转换为这3种进制表示的字符串，并且int(str, base)根据每个给定的进制把一个运行时字符串转换为一个整数

  - 复数
    - Python的复数常量写成实部+虚部的写法，这里虚部是以j或J结尾
    - 其中，实部从技术上讲可有可无，所以可能会单独表示虚部
    - 从内部看来，复数都是通过一对浮点数来表示的，但是对复数的所有的数字操作都会按照复数的运算法则进行
    - 也可以通过内置函数complex(real, imag)来创建复数

  - 编写其他的数字类型
    - 其中的一些通过调用导入的模块中的函数来创建(例如: 十进制和分数)

#### 内置数学工具的扩展
- Python还提供了一系列处理数字对象的工具:
  - 表达式操作符: +、-、*、/、>>、**、&等
  - 内置数学函数: pow、abs、round、int、hex、bin等
  - 公用模块: random、math等

- 尽管数字主要是通过表达式、内置函数和模块来处理，它们如今天也拥有很多特定于类型的方法
- 整数有各种各样的属性
- 集合既像一些集合一样也像一些数字一样，它也支持这两者的方法和表达式
- 表达式是大多数数字类型最基本的工具

### Python表达式操作符
- 表达式是处理数字的最基本的工具
- 当一个数字(或其他对象)与操作符相结合时，Python执行时将计算得到一个值
- 在Python中，表达式是使用通常的数学符号和操作符号写出来的

# 表5-2: Python表达式操作符及程序
操作符 | 描述
:------ | :------
yield x | 生成器函数发送协议
lambda args: expression | 生成匿名函数
x if y else: expression | 三元选择表达式
x or y | 逻辑或(只有x为假，才会计算y)
x and y | 逻辑与(只有x为真，才会计算y)
not x | 逻辑非
x in y, x not in y | 成员关系(可迭代对象、集合)
x is y, x is not y | 对象实体测试
x < y, x <= y, x > y, x >= y, x == y, x!= y | 大小比较，集合子集和超集值相等性操作符
x `<|>` y | 位或，集合并集
x ^ y | 位异或，集合交集
x & y | 位与，集合交集
x << y, x >> y | 左移或右移y位
x + y, x - y | 加法/合并，差法，集合差集
x * y, x % y, x / y, x // y | 乘法/重复，余数/格式化，除法: 真除法或floor除法
-x, +x | 一元减法，识别
~x |  按位求补(取反)
x ** y | 幂运算
x[i] | 索引(序列、映射及其他)点号取属性运算，函数调用
x[i:j:k] | 分片
x(...) | 调用(函数、方法、类及其他可调用的)
x.attr | 属性引用
(...) | 元组，表达式，生成器表达式
[...] | 列表，列表解析
{...} | 字典、集合、集合和字典解析

- 关于表5-2中的操作符的版本差异和最新添加:
  - Python 2.6中，值不相等可以写成 X != Y 或 X <> Y，在Python 3.0这中，值不相等测试使用 X != Y， 去掉了<>
  - 在Python 2.6中，一个后引号表达式'X'和repr(X)的作用相同，转换对象以显示字符串，由于其不好理解，Python 3.0 删除了这个表达式，使用更易理解的str和repr内置函数
  - 在Python 2.6和Python 3.0中，floor除法表达式(X // Y) 总是会把余数小数部分去掉;在Python 3.0中，X / Y 表达式执行真正的除法(保留余数) 和Python 2.6中的传统除法(截除为整数)
  - 列表语法([...])用于表示列表常量或列表解析表达式。后者是执行隐性循环，把表达式的结果收集到新的列表中
  - (...)语法用于表示元组和表达式，以及生成器表达式，后者是产生所需结果的列表解析的一种形式，而不是构建一个最终的列表
  - {...}语法表示字典常量，并且在Python 3.0中可以表示集合常量以及字典和集合解析
  - yield和三元选择表达式在Python 2.5及期以后的版本中可用。前者返回生成器中的send(...)参数，后者是一个多行if语句的缩写形式。如果yield不是单独地位于一条赋值语句的右边的话，需要用圆括号
  - 比较操作符可以连续使用: X < Y < Z的结果与 X < Y and Y < X相同
  - 在最近的Python中，分片表达式X[I:J:K]等同于用一个分片对象索引: X[slice(I, J, K)]
  - 在Python 2.X，混合类型的广义比较是允许的(把数字转换为一个普通类型，并且根据类型名称来排列其他的混合类型)。 在Python3.0中，非数字的混合类型的大小比较是不允许的，并且发异常，这包括按照代理排序
  - 在Python 3.0中，对字典的大小比较也不再支持(尽管支持相等性测试)；比较sorted(dict.items())是一种可能的替代

#### 混合操作所遵循的操作符优先级
- 当编写含有一个操作符以上的表达式时，Python将按照所谓的优先级法则对其进行分组，这个分组决定了表达式中部分的计算顺序

##### 表5-2根据操作符的优先级来排序
- 在表5-2中，表的操作符中越靠后的优先组越高，因此在混合表达式中要更加小心
- 表5-2中位于同一行的表达式在组合的时候通常从左到右组合(除了幂运算，它是从右向左组合的，还有比较运算，是从左到右连接的)

#### 括号分组的子表达式
- 如果用括号将表达式各部分进行分组的话，就可以完全忘掉优先级的事情了
- 当使用括号划分子表达式的时候，就会超越Python的优先级规则
- Python总会先行计算括号中的表达式，然后再将结果用在整个表达式中
- 在一个大型表达式中增加括号是个很好的方法，它不仅仅强制按照你想要的顺序进行计算，同时也增加了程序可读性

#### 混合类型自动升级
- 除了在表达式中混合操作符以外，也能够混合数字的类型
- 在混合类型的表达式中，Python首先将被操作的对像转换成其中最复杂的操作对象的类型，然后再对相同类型的操作对象进行数学运算
- Python是这样划分数字类型的复杂度的:
  - 整数比浮点数简单，浮点数比复数简单
  - 任何混合类型的表达式，其中一个操作对象是更为复杂的数字，则会导致其他的操作对象升级为一个复杂的数字，使得表达式获得一个复杂的结果
- 可以通过手动调用内置函数来强制转换类型;(然而，通常是没有必要这样做的。Python在表达式中自动升级为更复杂的类型，其结果往往就是你所想要的)
- 要记住所有这些混合类型转换仅仅在将数字类型(比如：一个整数和一个浮点数)混合到一个表达式中的时候才适用，这包括那些使用数字和比较操作符的表达式
- 一般来说，Python不会在其他的类型之间进行转换，除非你手动转换其中某个的类型
- 注意: 
  - Python 2.6中，非数字混合类型也可以比较，但是，不执行转换(混合类型的比较根据一个确定但任意的规则)
  - 在Python 3.0中，非数字混合类型的比较是不允许的，并且会引发异常

##### 预习: 运算符重载
- 留心所有的Python操作符可以通过Python的类或C扩展类型被重载(即实现)，让它也能工作于你所创建的对象中
- Python自身自动重载了某些操作符，能够根据所处理的内置对象的类型而执行不同的操作
- 这种特性通常称作多态。这个术语指操作的意义取决于所操作的对象的类型

### 在实际应用中的数字
- 最好的理解数字对象和表达式的方法就是看看它们在实际中的应用

#### 变量和基本的表达式
- 变量在它第一次赋值时创建
- 变量在表达式中使用将被替换为它们的值
- 变量在表达式中使用以前必须己赋值
- 变量像对象一样不需要在一开始进行声明

##### 换句话说，这些赋值会让变量a和b自动生成:
```python
% python
>>> a = 3                 # name created
>>> b = 4
```
- 文档字符串，即对象上附加的注释的文本
```python
>>> a + 1, a -1                   # Addition(3 + 1)，subtraction(3 -1)
(4, 2)
>>> b * 3, b / 2                  # Multiplication(4 * 3)， dvision(4/2)
(12, 2.0)
>>> a % 2, b ** 2                 # Modulus(remainder), power(4 ** 2)
(1, 16)
>>> 2 + 4.0, 2.0 ** b             # Mixed-type conversions
(6.0, 16.0)
```
- 从技术上讲，这里的会显示所得到的结果是有两个值的元组，因为输入在提示符的那行包含了两个被逗号分开的表达式
- 这也就是显示的结果包含在括号里的原因
- 如果使用一个从未被赋值的不同的变量，Python将会报告有错误而不是赋给默认的值
```python
>>> c * 2
Traceback (most recent call last):
  File "<stdin>", line 1, in ?
NameError: name 'c' is not defined
```
- 在Python中，变量并不需要预声明，但是在使用之前，至少要赋一次值
- 这意味着在对其进行加法运算时要计数器初始化为0， 在列表后添加元素前，要首先初始化列表为一个空列表

```python
>>> b / 2 + a                   # Same as ((4 / 2) + 3 )
5.0
>>> print(b / (2.0 + a))        # Same as (4 / (2.0 + 3))
0.8 
```
- 在第一个表达式中，没有括号，所以Python自动根据运算符的优先级法则将各部分分组
- "/" 比 "+" 位置靠后，它的优先级更高，所以首先进行"/"运算

P159